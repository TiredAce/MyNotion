# Part8 Hash

>[1. Hash](#1)
>
>[2. 习题](#2)

<h2 id = "1">1. Hash</h2>

### 1.1 Hash表

`Hash`表又被称为散列表，一般由`Hash`函数与链表结构共同组成（拉链法Hash表）。和离散化思想一致，把复杂的信息映射到一个容易维护的值域内。因为值域变简单、范围变小，有可能会造成两个数被映射成同一个值，这种现象叫做“hash冲突”。

一种解决的办法就是拉链法，将冲突的点用链表串连起来。其主要操作为：

1. 计算`Hash`函数的值
2. 定位到对应链表中依次遍历、比较。

较好的`Hash`表，原始信息会比较均匀的分配到各个表头，从而使每次查找、统计的时间降低到表头接的链表长度。如果不存在冲突，那么每次查找的时间复杂度期望能达到$O(1)$。

### 1.2 Hash表的两种实现方式

1. 开放寻址法

开放寻址法的思想就是如果哈希函数存在冲突，就继续向后找坑位，直到找到没有数的坑位，寻找坑位的函数如下：

```c++
const int N = 2e5 + 3;

int find(int x)
{
    int t = (x % N + N) % N;
    while (h[t] != null && h[t] != x)
    {
        t ++ ;
        if (t == N) t = 0;
    }
    return t;
}
```

`find`函数同时能完成**查找**和**寻址**的操作。

2. 拉链法

拉链法的插入函数，就是将节点接到映射后的头节点后，代码如下：

```c++
void insert(int x)
{
    int k = (x % N + N) % N;
    e[idx] = x;
    ne[idx] = h[k];
    h[k] = idx ++ ;
}
```

拉链法的查找函数，就是查找映射后的链表中是否存在该元素。代码如下：

```c++
bool find(int x)
{
    int k = (x % N + N) % N;
    for (int i = h[k]; i != -1; i = ne[i])
        if (e[i] == x)
            return true;
    return false;
}
```

### 1.2 字符串Hash

字符串`Hash`函数把一个任意长度的字符串映射成一个非负整数，并且冲突的概率几乎为零。
