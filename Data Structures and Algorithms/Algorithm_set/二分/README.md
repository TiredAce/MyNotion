# 二分

>[1. 二分](#1)
>
>[2. 习题](#2)

<h2 id = "1">
1. 二分
</h2>

二分的基础用法就是在单调序列或是单调函数中查找，因此当问题的答案具有单调性时，可以使用二分查找。

二分分为两种，在整数集合上的二分与在实数域上的二分：

1. 正数域上的二分模板

查找单调递增序列中$\ge x$的数中最小的一个：

```c++
while (l < r)
{
	int mid = l + r >> 1;
	if (a[mid] >= x) r = mid; else l = mid + 1;
}
```

查找单调递增序列中$\le x$的数中最大的一个：

```c++
while (l < r)
{
	int mid = l + r + 1 >> 1;
	if (a[mid] <= x) l = mid; else r = mid - 1;
}
```

 注意一个细节，这里采用的是右移取整；而不是除$2$取整，这是因为，前者是向下取整，后者是向$0$取整，后者在负数域不能正常工作，因此整数二分通常使用前者来取`mid`。

2. 实数域上的二分

实数域二分十分的简单，二分模板如下：

```c++
while (l - r > 1e-5)
{
	double = (l + r) / 2;
	if (check(mid)) r = mid; else l = mid;
}
```

对于精度无法确定的问题，可以通过固定次数的二分方法，模板如下：

```c++
for (int i = 1; i <= 1000; i ++)
{
	double = (l + r) / 2;
	if (check(mid)) r = mid; else l = mid;
}
```

二分最常用于二分答案，把一个最优化问题抽象成函数，如果答案在定义域上有二段性，那么就在定义域执行二分。详细的用法可以查看习题部分。

<h2 id = "2">
2. 习题
</h2>
>[1. Best Cow Fences](#2.1)
>
>[2. 四平方和](#2.2)

<h3 id = "2.1">
2.1. Best Cow Fences
</h3>

**题目描述**：给定一个序列，求一个平均值最大的，长度不小于$L$的子段。

**思路**：二分答案，判定”是否存在一个长度不小于$L$的字段，平均值不小于二分值“。将数列中每个数都减去二分值，判定”是否存在一个长度不小于$L$的字段，子段和非负“。所以问题就转换为是否有子段非负的区间，这是个经典的$DP$问题。

[Code:2_1.cpp]()

<h3 id = "2.2">
2.2 四平方和
</h3>
**题目描述**：四平方和定理，又称为拉格朗日定理,每个正整数都可以表示为至多 $4$ 个正整数的平方和。对于一个给定的正整数，可能存在多种平方和的表示法。要求你对 $4$ 个数排序：$0≤a≤b≤c≤d$。并对所有的可能表示法按$ a,b,c,d$ 为联合主键升序排列，最后输出第一个表示法。

**思路一**：hash表，循环遍历两个变量，存入hash表中，再遍历另外两个变量去找互补的一部分。易证第一个找到的就是字典序最小的。

[Code:2_2_1.cpp]()

**思路二**：二分，本质思想于思路一一致，首先遍历两个变量，将变量与平方和存入到结构体中，并排序。最后遍历后两个变量并二分查找。找到的第一个一定就是字典序最小的。
