# Part1 DFS与BFS

> [1. 树与图的遍历](#1)
>
> [2. DFS](#2)
>
> [3. 剪枝](#3)
>
> [4. 迭代加深](#4)
>
> [5. BFS](#5)
>
> [6. 广搜变形](#6)
>
> [7. 总结练习](#7)

<h3 id = "1">
1. 树与图的遍历
</h3>

树与图最常见的存储方式就是使用一个邻接表保存它们的边集。以下默认属于图的存储方式是使用邻接表的方式存储。给定$N$个点图或者树时，其几点编号均为`1~N`，它们的边都存储在一个邻接表中，邻接表以`head`数组为表头，使用`ver`和`edge`数组分别存储边的终点和权值，使用`next`数组模拟链表的指针。

#### 1.1 树与图的深度优先遍历，树的DFS序、深度和重心

深度优先遍历，就是在每个点上面对多条分支时，任意选一条边走下去，执行递归，直到回溯到`x`后，再考虑走向其他的边，调用`dfs(1)`，对一张图进行深度优先遍历。

```c++
void dfs(int x) {
	v[x] = 1;  // 标记访问过的点
	for (int i = head[x]; i; i = next[i]) {
		int y = ver[i];
		if (v[y]) continue;  // 访问过就跳过
		dfs(y);
	}
}
```

深度优先遍历中每个点和每条边都恰好访问一次，因此时间复杂度为$O(N+M)$。

1. 时间戳

按照上述深度优先遍历的过程，每个结点都会被访问一次，一次给这些结点按照访问的顺序用整数进行标记，该标记就被称为时间戳，记为`dfn`。

2. 树的DFS序

一般来说，对树进行深度优先遍历时，对于每个结点，在刚进入递归后以及即将回溯前各记录一次该点的编号，最后产生长度为`2N`的结点序列就称为树的`DFS`序。

```c++
void dfs(int x)
{
	a[++ m] = x;
	v[x] = 1;
	for (int i = head[x]; i; i = next[i])
	{
		int y = ver[i];
		if (v[y]) continue;
		dfs(y);
	}
	a[++ m] = x;
}
```

`DFS`序的特点是：每个结点x的编号在序列中恰好出现两次。设这两次出现的位置是`L[x]`与`R[x]`，那么闭区间`[l[x], R[x]]`就是以`x`为根的子树的`DFS`序。这使我们子啊很多与树相关的问题中，可以通过`DFS`序把子树统计转化为序列上的区间统计。

<div align=center>
<img src="./../assets/blog_res/dfs和bfs.assets/image-20230323221840701.png" alt="image-20230323221840701" width="400px" />
</div>

3. 树的深度

树种各个结点的深度十一种自顶向下的统计信息，从深度为`0`的根节点出发，向下求出每个结点的深度。

4. 树的重心

还有许多信息是自底向上进行统计的，比如每个结点子树的大小，我们用`size[x]`来表示子树的大小。如果结点`x`的子节点是$y_1 $~$y_k$，则以`x`为根的子树的大小就是$size[x]=size[y_1]+size[y_2]+...+size[y_k]+1$。

对于一个结点`x`，如果我们把它从树种删除，那么原来的一颗树可能会分为若干不想连的部分，其中每一部分都是一颗子树。假设`max_part`表示删除结点后产生子树中，最大的一颗大小。使`max_part`函数取到最小值的结点`p`就称为整棵树的重心。下面是求解重心的代码。最后全局变量中的`ans`就是最终答案。

```c++
int dfs(int u, int v)
{
    int sums = 1, max_sz = 0;
    for (int i = h[u]; i; i = ne[i])
    {
        int j = e[i];
        if (j == v) continue;
        int sz = dfs(j, u);
        sums += sz;
        max_sz = max(max_sz, sz);
    }
    max_sz = max(max_sz, n - sums);
    ans = min(ans, max_sz);
    return sums;
}
```

