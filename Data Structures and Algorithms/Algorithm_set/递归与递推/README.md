# Part5 递归与递推

>[1. 递归与递推](#1)
>
>[2. 习题](#2)

<h2 id = "1">
1. 递归与递推
</h2>

在设计算法时，通过划分、归纳、提取、抽象来帮助提高程序状态空间的效率。递推和递归时遍历状态空间的两种基本方式。

对于一个代求的问题，当它局限在某处边界，某个小范围或者某种特殊情形下时，答案通常是已知的。如果能够将该解答的应用场景扩大到原问题的状态空间，并且扩展过程的每个步骤具有相似性，就可以考虑使用递推与递归。

以已知的“问题边界”为起点向“原问题”正向推导的拓展方式就是递推，然而很多时候，推导的路线难以确定，这个时候就要从“原问题”出发，达到"问题边界"，再回溯到“原问题”，这样的步骤就是递归。

理论就是以上这些，具体实现还需要多练习。。。

<h2 id = "2">
2. 习题
</h2>

>[1. 约数之和 (数论+分治)](#2.1)

<h3 id = "2.1">
2.1. 约数之和
</h3>


**题目描述**：假设现在有两个自然数 $A$ 和 $B$，$S$ 是 $A^B$ 的所有约数之和。请求出 $S\ mod\ 9901$ 的值是多少。

**数据范围**：$0 \le A, B \le 5 \times 10^7$

**思路**：首先根据算术基本定理可以将$A$表示为$p_1^{c_i}p_2^{c_2}p_3^{c3}...p_n^{c_n}$。那么$A^B$就可以表示为$p_1^{Bc_i}p_2^{Bc_2}p_3^{Bc3}...p_n^{Bc_n}$。再根据乘法分配律，$A^B$的约数之和就为下式：

$$
(1+p_1 + p_1^2 + ...+p_1^{Bc_i})(1+p_2 + p_2^2 + ...+p_2^{Bc_2})...(1+p_n + p_n^2 + ...+p_n^{Bc_n})
$$

根据上式就能将问题转换为求 $1+p + p^2 + ...+p^{c}$。

可以根据$c$的奇偶性分类讨论，如果$c$为奇数：

$$
上式=sum(p, c)=(1+p+...+p^{\frac{c - 1}{2}}) + (p^\frac{c + 1}{2} + ...+ p^{c})
$$

$$
=(1+p+...+p^{\frac{c - 1}{2}}) + p^{\frac{c+1}{2}}(1+..+p^\frac{c-1}{2})
$$


$$
= (1 + p^{\frac{c+1}{2}})(1+p+...+p^{\frac{c - 1}{2}})
$$

$$
=(1 + p^{\frac{c+1}{2}}) \times sum(p, \frac{c - 1}{2})
$$

如果$c$为偶数可以将最后一个数单独提出即可：

$$
上式 = 1+p + p^2 + ...+p^{c} = sum(p, c - 1) + p^c
$$
可以发现上述计算过程$c$为奇数时，能将问题的规模降低一半再结合快速幂计算，能将时间复杂度控制到$O(logn)$

[Code:2_1.cpp](./2_1.cpp)
