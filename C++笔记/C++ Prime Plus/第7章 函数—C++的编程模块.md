## 第7章 函数—C++的编程模块

>[7.2 函数参数和按值传递](#7.2)
>
>[7.3 函数和数组](#7.3)
>
>[7.4 函数和二维数组](#7.4)
>
>[7.6 函数和结构](#7.6)
>
>[7.10 函数指针](#7.10)

<h3 id="7.2">7.2函数参数和按值传递</h3>

​		给出以下函数头：

```c++
double cube(double x);
```

​		被调用时，该函数将创建一个新的变量名为`x`的`double `变量，并将其初始化。这样`cube()`执行的操作将不会影响`main()`函数的中的数据，因为`cube()`使用的`side`的副本。用于接收传递值的变量被称为形参。传递给函数的值被称为实参。

​		在函数中声明的变量时该函数私有的。在函数被调用时，计算机将为这些变量分配内存；函数结束时，计算机将释放这些变量使用的内存。

<h3 id="7.3">7.3 函数和数组</h3>

​		`C++`将数组名解释为其第一个元素的地址：

```c++
cookies == &cookies[0];
```

​		但是该规则有例外。首先，数组声明使用数组名来标记存储位置；其次对数组名使用`sizeof `将得到整个数组的程长度；第三，将地址运算符`&`用于数组名时，将返回整个数组的地址，例如一个包含`8`个`int`类型的数组将会返回一个`32`字节内存块。

​		`cookies`是其第一个元素的地址，因此函数传递的是地址。由于数组的元素类型为`int`，因此`cookies`的类型必须是`int`指针，即`int *`。这表明，正确的函数头应该为：

```c++
int sum_arr(int * arr, int n);
```

​		因此就能得到以下两个恒等式：

```c++
arr[i] == *(arr + i)
&arr[i] == arr + i
```

​		将数组的首地址传入函数中，对`arr`使用`sizeof`操作符得到的是`4`，这是由于`sizeof cookies`是整个数组的长度，而`sizeof arr`只是指针变量的长度。这也是必须显示传递数组长度，而不能在函数中使用`sizeof`函数的原因。

##### 1. 显示数组及使用const保护数组

​		对于显示数组，需要确保显示函数不修改原始数组。除非函数的目的就是修改传递给它的数据，否则应避免发生这种情况。为防止函数无意中修改数组中的内容，可在声明形参时使用关键词`const`。

```c++
void show_arr(const double arr[], int n);
```

​		该声明指出，指针`arr`指向的是常量数据。这意味着不能`arr`修改该数据。这并不是意味着原始数组必须是常量，而只是意味着不能在`show_array()`函数中使用`arr`来修改这些数据。因此，`show_array()`将数组是为只读数据。

##### 2. 指针和const

​		将`const`用于指针有一些很微妙的地方。可以用两种不同的方式将`const`关键字用于指针。第一种方式是让指针指向一个常量对象，这样可以放置使用指针来修改所指向的值，第二种方法是将指针本身声明为常量，这样可以防止修改指针指向的位置。

​		**第一种如下**，声明一个指向常量的指针`pt`：

```c++
int age = 39;
const int * pt = &age;
```

​		该声明指出，`pt`指向一个`const int`，因此不能使用`pt`来修改这个值。换句话说，`* pt`的值为`const int`，不能被修改。但是`pt`的声明并不代表着它指向的是一个常量，而只是意味着对`pt`而言，这个值是常量。

​		对于一个`const`变量，必须要用`const int`类型的指针！！！

```c++
const int earth = 9;
const int *pe = &earth;     // VALID

int *pe2 = &earth;         // INVALID
```

**尽可能的使用const**

> 将指针参数声明为指向常量数据的指针有两条理由：
>
> * 这样可以避免由于无意间操作修改数据而导致的编程错误
> * 使用`const`使得函数能够处理`const`和非`const`实参，否则将只能处理非`const`数据
>
> 如果条件允许，则应该将指针形参声明为指向`const`的指针

​		**第二种如下**，这样的使用使得无法修改指针的值：

```c++
int sloth = 3;
const int * ps = &sloth;
int * const finger = &sloth;
```

​		在最后一个声明中，关键字`const`的位置与以前不同，这种声明格式使得指针只能指向该位置，不能对指向的位置进行修改，但是允许对该指向位置的值进行修改。简而言之，`finger`和`*ps`是`const`，而`*finger`和`ps`不是。

<h3 id="7.4"> 7.4 函数和二维数组
</h3>

​		假设有下面代码：

```c++
int data[3][4] = {{1, 2, 3, 4}, {1, 2, 3, 4}, {1, 2, 3, 4}};
int total = sum(data, 3);
```

​		 函数为何只将行数`3`作为参数，而不将列数作为参数呢？

​		`data`是一个数组名，该数组有`3`个元素。第一个元素本身就是一个数组，由`4`个元素组成。因此`data`的类型是指向由`4`个`int`组成组成的数组的指针，因此正确的原型如下：

```c++
int sum(int (*arr)[4], int size);
```

​		还有另一种格式，这种格式与上述原型的含义完全相同，但可读性更强：

```c++
int sum(int arr[][4], int size);
```

​		上述两个原型指出，`arr`是指针而不是数组。还需要注意的是，由指针类型指出，它指向由`4`个`int`组成的数组。因此，指针类型指定了列数，这就是没有将列数作为独立的函数参数进行传递的原因。

​		对于获取数组的元素，可以使用如下操作：

```c++
ar2[r][c] == *(*(ar2 + r) + c);
```

<h3 id="7.6"> 7.6 函数和结构
    
</h3>

​		结构变量和数组一样，能存储多个数据项，但涉及函数时，结构变量的行为更接近基本的单值函数。也就是说，与数组不同，结构将其数据组合成单个实体或数据对象，该实体被视为一个整体。

​		使用结构编程时，最直接的方法就是像处理基本类型那样处理结构；也就是说，将结构作为参数传递，并在需要时将结构用作返回值使用。然而，按值传递结构有一个缺点。如果结构非常大，则复制结构将增加内存要求，降低系统运行的速度。处于这些原因，更倾向用传递结构的地址的方法，然后使用指针来访问结构的内容。`C++`提供了第三种选择，那就是按照**引用**传递。

<h3 id="7.10">
    7.10 函数指针
</h3>

​	与数据项类似，函数也有地址。函数的地址是存储其机器语言代码的内存的开始地址。通常，这些地址对用户而言不重要。但是对于程序来说却很有用，可以编写将另一个函数的地址作为参数的函数。这样第一个函数能够找到第二个函数，并运行它。与直接调用另一个函数相比，这种方式十分的复杂，但是它允许不同时间传递不同函数的地址，着意味着可以不同的时间使用不同的函数。

#### 7.10.1 函数指针的基础知识

​		假设要设计一个名为`estimate()`的函数，估算编写指定行数的代码所需要的时间，并且希望不同的程序员都将使用该函数。为此，必须能够完成下面的工作：

* 获取函数的地址
* 声明一个函数指针
* 使用函数指针来调用函数

**1. 获取函数的地址**

​		获取函数的地址很简单，只要使用函数名就可。也就是说，如果`think()`是一个函数，则`think`就是该函数的地址。要将函数作为参数进行传递，必须传递函数名。一定要区分传递的是函数的地址还是函数的返回值。

**2. 声明函数指针**

​		声明指向某种数据类型的指针时，必须指定指针指向的类型。同样，声明指向函数的 指针时，也必须指定指针指向的函数类型。例如对于函数类型如下的函数：

```C++
double pam(int);
```

​		正确的指针类型声明为：

```c++
double (*pf)(int);
```

​		这与`pam()`声明类似，这是将`pam`替换为`(*pf)`。由于`pam`是函数，因此`(*pf)`也是函数。如果`(*pf)`是函数，则`pf`就是函数指针。

​		正确的声明`pf`后，便可以将相应函数的地址赋值它：

```
double pam(int);
double (*pf)(int);
pf = pam;
```

P260
