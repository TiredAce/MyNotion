## 第5章 继承

>[5.1 类、超类和子类](#5.1)
>
>[5.2 Object：所有类的超类](#5.2)
>
>[5.3 泛型数组列表](#5.3)

<h3 id = "5.1">
5.1 类、超类和子类
</h3>

#### 5.1.1 定义子类

可以如下继承`Employee`类来定义`Manager`类，这里使用关键字`extends`表示继承。

```java
public class Manager extends Employee
{
    added methods and fields
}
```

>**C++注释**：`Java`和`C++`定义继承的方式十分相似。`Java`用关键词`extends`代替了`C++`中的`:`。在`Java`中，所有的继承都是公共继承，而没有私有继承和保护继承。

关键词`extends`表示正在构造的新类派生于一个已存在的类，这个已存在的类称为超类；新类称为子类。超类和子类是最常用的两个术语。

#### 5.1.2 覆盖方法

超类中的有些方法对子类`Manager`并不一定适用。为此，需要提供一个新的方法来覆盖超类中的这个方法。

如何实现这个方法，乍一看似乎很简单，只要放回`salary`和`bonus`字段的总和就可以了，不过，需要指出我们希望使用超类`Employee`中的`getSalary`方法，而不是当前类的这个方法。可以使用使用特殊的关键字`super`解决这个问题：

```java
super.getSalary();
```

>**注释**：有些人认为`super`与`this`引用时类似的概念，实际上，这样比较并不太恰当。这是因为`super`不是一个对象的引用，例如，不能将值`super`赋给另一个对象变量，它只是一个指示编译器调用超类方法的特殊关键词。

>**C++注释**：在`Java`中使用关键词`super`调用超类的方法，而在`C++`中则采用超类名加`::`操作符的形式。例如`Employee::getSalary`而不是`super.getSalary`。

#### 5.1.3 子类构造器

提供一个构造器

```java
public Manger(String name, double salary, int year, int month, int day)
{
	super(name, salary, year, month, day);
	bonus = 0;
}
```

这里的`super`具有不同的含义，调用超类`Employee`中带有各类参数。

子类的构造器不能访问超类的构造器，所以必须通过一个构造器来初始化这些私有字段，可以利用特殊的`super`语法调用这个构造器。使用`super`调用构造器的语句必须是子类构造器的第一条语句。

如果子类的构造器没有显示的调用超类的构造器，将自动地调用超类的无参数构造器。如果超类没有无参数构造器，并在子类中也没有显式地调用超类的其他构造器，`Java`编译器就会报告一个错误。

> **注释**：关键词`this`有两个含义:一是指示隐式参数的引用，二是调用该类的其他构造器。`super`关键字也有两个含义：一个是调用超类的方法，二是调用超类的构造器。在调用构造器的时候，`this`和`super`这两个关键字紧密相关。

一个对象变量可以指示多种实际类型的现象称为多态。在运行时能够自动地选择适当的方法，被称为动态绑定。

> **C++注释**：在`C++`中，如果希望实现动态绑定，需要成员函数声明为`virtual`。在`Java`中，动态绑定是默认的行为。如果不希望让一个方法是虚拟的，可以将它标记为`final`。

#### 5.1.5 多态

继承就是"is-a"的规则，其另一种表述是替换原则。它指出程序中出现超类对象的任何地方都可以使用子类对象替换。

```java
Employee e;
e = new Manager(...);
```

> **警告**：在`Java`中，子类引用的数组可以转换成超类引用的素组，而不需要不需要使用强制类型转换。
>
> ```java
> Manager[] managers = new Manager[10];
> ```
>
> 将它转换成`Employee[]`数组完全是合法的：
>
> ```java
> Employee[] staff = managers;
> ```
>
> 这样做肯定不会有问题，不过实际上会发生一些令人惊讶的事情。要切记`managers`和`staff`引用的是同一个数组。
>
> 这样会导致如下的语句也能实现：
>
> ```java
> staff[0] = new Employee(...);
> ```
>
> 编译器会接受这种赋值操作，这会导致会把一个普通员工混入到经理行列中，这会导致在调用经理方法时出现错误。
>
> 为了保证不发生这类破坏，所有数组都要牢记创建时的元素类型，并负责监督仅将类型兼容的引用存储到数组中。

#### 5.1.6 理解方法调用

假设要调用`x.f(args)`，隐式参数`x`声明为类`C`的一个对象。下面是调用过程的详细描述：

1. 编译器查看对象的声明类型和方法名。编译器将会一一列举所有可访问的方法（超类的私有方法）。至此，编译器已知道所有可能被调用的候选方法。**至此，编译器已知道所有可能被调用的候选方法**

2. 接下来，编译器要确定方法调用中提供的参数类型。如果所有方法中存在一个与所提供参数类型完全匹配的方法，就选择这个方法。这个过程称为重载解析。由于允许类型转换，所以情况可能会变得很复杂。如果找不到可匹配的方法，编译器就会报告一个错误。**至此，编译器已经知道需要调用的方法的名字和参数类型**

> **注释**：方法的名字和参数列表称为方法的签名。如果在子类中定义一个与超类签名相同的方法，那么子类中的这个方法就会覆盖超类中这个相同签名的方法。
>
> 放回类型不是签名的一部分。不过在覆盖一个方法时，需要保证返回类型的兼容性。允许子类将覆盖方法的返回类型改为原返回类型的子类型。

3. 如果时`private`方法，`static`方法，`final`方法或者构造器，那么编译器将可以准确地知道应该调用哪个方法。这称为**静态绑定**。与此对应的是，如果要调用的方法依赖于隐式参数的实际类型，那么必须在运行时使用**动态绑定**。

4. 程序运行并且采用动态绑定调用方法时，虚拟机必须调用与`x`所引用对象的实际类型对应的那个方法。

#### 5.1.7 阻止继承：final类和方法

不允许拓展的类被称为`final`类。如果在定义类的时候使用了`final`修饰符就表明这个类是`final`类。声明的格式如下：

```java
public final class Executive extends Manger
{
	...
}
```

类中的某个特定方法也可以被声明为`final`，如果这样做，子类就不能覆盖这个方法。

```java
public class Employee{
	...
	public final String getName()
	{
		return name;
	}
}
```

>**注释**：对于`final`字段来说，构造对象之后就不允许改变它们的值了。如果将一个类声明为`final`，只有其中的方法自动地成为`final`，而不包括字段。

#### 5.1.8 强制类型转换

有时候需要将某个类的对象引用转换成另一个类的对象引用。要完成对象引用的强制类型转换，转换语法与数值表达式的强制类型转换类似。

```java
Manager boss = (Manager) staff[0];  // staff[0]引用的是Manager对象
```

进行强制类型转换的唯一原因是，要暂时忽视对象的实际类型之后使用对象的全部功能。例如，上述代码中，`staff`数组中某些元素是普通员工，所以`staff`数组必须是`Employee`对象的数组。我们需要将数组中引用经理的元素复原成`Manager`对象，以便能够访问新增加的所有变量。

将一个值存入变量时，编译器将检查你是否承诺过多。如果将一个子类的引用赋给一个超类变量，编译器是允许的。但将一个超类的引用赋给一个子类变量时，就承诺过多了。必须进行强制类型转换，这样才能够通过运行时的检查。

假设`staff[1]`中不是`Manager`对象，那么如下代码就会出现`ClassCastException`异常：

```java
Manager boss = (Magnager) staff[1];  // error
```

因此，良好的程序习惯就是在强制类型转换之前，先检查是否能够成功的转换。谓词只需要使用`instanceof`操作符就可以实现。

```java
if (staff[1] instanceof Manager)
{
	boss = (Manager) staff[1];
}
```

综上所述：

* 强制类型转换只能在继承层次内进行强制类型转换。
* 在强制类型转换之前应该使用`instanceof`检查。

#### 5.1.9 抽象类

自下而上的继承层次关系中，越上层的结构具有一般性，我们叫它为抽象类，抽象类必须要有具有共性的抽象方法并使用`abstract`关键字来修饰。为了提高程序的清晰度，包含一个或多个抽象方法的类本身必须被声明为抽象。

```java
abstract class Person {
    private String name;
    public abstract String getName();
}
```

拓展抽象类有两种方法，一种就是在子类保留抽象类的部分或全部抽象方法，这样子类也是抽象类；第二种就是全部定义方法。

不含抽象方法的类，也可以声名为抽象类；但是有抽象方法的类，一定是抽象类。

抽象类不能实例化，但是可以引用具体子类的对象：

```java
// new Person();    错误的
Person p = new Employee();
```

> **C++注释**：C++中，有一种抽象方法称为纯虚函数，要在某位用`=0`标记，如下：
>
> ```c++
> class Person
> {
> public:
> 	virtual string get_name() = 0;
> }
> ```
>
> 如果有一个纯虚函数，这个`C++`类就是抽象类。

#### 5.1.10 受保护对象

用`protected`修饰的**字段**可以同一个包中的类访问所访问。

实际运用的时候要谨慎使用受保护字段。假设你的类中有受保护字段。如果从这个类中再派生出新的类，并可以访问你的受保护字段，这样违背的封装的特性。

**受保护方法**更加的有实际意义，如果需要限制某个方法的使用，就可以将它声明为受保护类。这表明子类得到了信任，能够访问此方法。其他的类则不行

`Java`中修饰符的小结：

1. 仅本类可见——private
2. 对外部类完全可见——public
3. 对本包和所有子类可见——protected
4. 对本包可见——默认

<h3 id = "5.2">
5.2 Object：所有类的超类
</h3>

#### 5.2.1 Object类型的变量

可以使用`Object`类型的变量引用任何类型的对象。在`Java`中，只有基本类型不是对象，所有的数组类型，不管是数组对象还是基本类型数组都扩展了`Object`类。

#### 5.2.2 equals方法

`Object`类中的`equals`方法用于检测一个对象是否等于另外一个对象。实现的方式是看两个对象的引用是否相等。如果两个对象引用相同，那这两个对象一定相等。不过，通常需要基于状态检测对象的相等性，如果两个对象有相同的状态，才认为这两个对象是相等的。例如比较两个员工的重写代码如下：

```java
class Employee {
    private String name;
    public boolean equals(Object otherObject) {
        if (this == otherObject) return true;
        if (otherObject == null) return false;
        if (getClass() != otherObject.getClass()) return false;
        return name.equals(((Employee) otherObject).name);
    }
}
```

`getClass`返回对象所属的类，只有两个对象所属的类相等，才可能相等。

在子类中定义`equals`，首先调用超类中的`equals`方法。如果检查失败，对象就不可能相等。

#### 5.2.3 相等测试与继承

一个完美的`equals`方法的建议：

1. 显示参数命名为`otherObject`，稍后强制转换为`other`变量。
2. 检测`this`与`otherObject`是否相等；
3. 检测`otherObject`是否为`null`，如果为`null`返回`false`。
4. 比较`this`与`otherObject`的类。如果`equals`的语义可以在子类中改变，就使用`getClass`检测；如果所有的子类都有相同的相等性语义，可以使用`instanceof`检测。
5. 将`otherObject`强制转换为相应的类型变量
6. 使用`==`比较基本类型字段，用`Objects.equals`比较对象字段。

如果在子类中重新定义了`equals`，就要在其中包含一个`super.equals(other)`调用。

#### 5.2.4 hashCode方法

散列值（hash code）是由对象导出的一个整数值。由于`hashCode`方法定义在`Object`类中，因此每个对象都有一个默认的散列码，其值由对象的存储地址得出。注意，字符串的散列码是由内容导出的，也就是说字符串字面值相等，那么散列值相等。

`equals`与`hashCode`的定义必须相容；如果`x.equals(y)`返回`true`。那么两者的`hashCode`方法返回值也需要相等。

#### 5.2.5 toString方法

`toString`方法返回表示对象值的一个字符串。它会返回表示对象值的一个字符串。

设计子类的应该定义自己的`toString`方法，并加入子类的字段。调用超类的`toString`方法，只需要使用`super.toString()`即可。

<h3 id = "5.3">
5.3 泛型数组列表
</h3>

`ArrayList`类似于数组，但在添加或删除元素时，它能够自动地调整数组容量，而不需要为此编写任何代码。

`ArrayList`是一个有类型参数的泛型类，为了指定数组列表保存的元素对象类型，需要用一对尖括号将类名括起来追加到`ArrayList`后面，例如，`ArrayList<Employee>`。

#### 5.3.1 声明数组列表

