## 第5章 继承

>[5.1 类、超类和子类](#5.1)

<h3 id = "5.1">
5.1 类、超类和子类
</h3>

#### 5.1.1 定义子类

可以如下继承`Employee`类来定义`Manager`类，这里使用关键字`extends`表示继承。

```java
public class Manager extends Employee
{
    added methods and fields
}
```

>**C++注释**：`Java`和`C++`定义继承的方式十分相似。`Java`用关键词`extends`代替了`C++`中的`:`。在`Java`中，所有的继承都是公共继承，而没有私有继承和保护继承。

关键词`extends`表示正在构造的新类派生于一个已存在的类，这个已存在的类称为超类；新类称为子类。超类和子类是最常用的两个术语。

#### 5.1.2 覆盖方法

超类中的有些方法对子类`Manager`并不一定适用。为此，需要提供一个新的方法来覆盖超类中的这个方法。

如何实现这个方法，乍一看似乎很简单，只要放回`salary`和`bonus`字段的总和就可以了，不过，需要指出我们希望使用超类`Employee`中的`getSalary`方法，而不是当前类的这个方法。可以使用使用特殊的关键字`super`解决这个问题：

```java
super.getSalary();
```

>**注释**：有些人认为`super`与`this`引用时类似的概念，实际上，这样比较并不太恰当。这是因为`super`不是一个对象的引用，例如，不能将值`super`赋给另一个对象变量，它只是一个指示编译器调用超类方法的特殊关键词。

>**C++注释**：在`Java`中使用关键词`super`调用超类的方法，而在`C++`中则采用超类名加`::`操作符的形式。例如`Employee::getSalary`而不是`super.getSalary`。

#### 5.1.3 子类构造器

提供一个构造器

```java
public Manger(String name, double salary, int year, int month, int day)
{
	super(name, salary, year, month, day);
	bonus = 0;
}
```

这里的`super`具有不同的含义，调用超类`Employee`中带有各类参数。

子类的构造器不能访问超类的构造器，所以必须通过一个构造器来初始化这些私有字段，可以利用特殊的`super`语法调用这个构造器。使用`super`调用构造器的语句必须是子类构造器的第一条语句。

如果子类的构造器没有显示的调用超类的构造器，将自动地调用超类的无参数构造器。如果超类没有无参数构造器，并在子类中也没有显式地调用超类的其他构造器，`Java`编译器就会报告一个错误。

> **注释**：关键词`this`有两个含义:一是指示隐式参数的引用，二是调用该类的其他构造器。`super`关键字也有两个含义：一个是调用超类的方法，二是调用超类的构造器。在调用构造器的时候，`this`和`super`这两个关键字紧密相关。

一个对象变量可以指示多种实际类型的现象称为多态。在运行时能够自动地选择适当的方法，被称为动态绑定。

> **C++注释**：在`C++`中，如果希望实现动态绑定，需要成员函数声明为`virtual`。在`Java`中，动态绑定是默认的行为。如果不希望让一个方法是虚拟的，可以将它标记为`final`。

#### 5.1.5 多态

继承就是"is-a"的规则，其另一种表述是替换原则。它指出程序中出现超类对象的任何地方都可以使用子类对象替换。

```java
Employee e;
e = new Manager(...);
```

> **警告**：在`Java`中，子类引用的数组可以转换成超类引用的素组，而不需要不需要使用强制类型转换。
>
> ```java
> Manager[] managers = new Manager[10];
> ```
>
> 将它转换成`Employee[]`数组完全是合法的：
>
> ```java
> Employee[] staff = managers;
> ```
>
> 这样做肯定不会有问题，不过实际上会发生一些令人惊讶的事情。要切记`managers`和`staff`引用的是同一个数组。
>
> 这样会导致如下的语句也能实现：
>
> ```java
> staff[0] = new Employee(...);
> ```
>
> 编译器会接受这种赋值操作，这会导致会把一个普通员工混入到经理行列中，这会导致在调用经理方法时出现错误。
>
> 为了保证不发生这类破坏，所有数组都要牢记创建时的元素类型，并负责监督仅将类型兼容的引用存储到数组中。

#### 5.1.6 理解方法调用

假设要调用`x.f(args)`，隐式参数`x`声明为类`C`的一个对象。下面是调用过程的详细描述：

1. 编译器查看对象的声明类型和方法名。编译器将会一一列举所有可访问的方法（超类的私有方法）。至此，编译器已知道所有可能被调用的候选方法。**至此，编译器已知道所有可能被调用的候选方法**

2. 接下来，编译器要确定方法调用中提供的参数类型。如果所有方法中存在一个与所提供参数类型完全匹配的方法，就选择这个方法。这个过程称为重载解析。由于允许类型转换，所以情况可能会变得很复杂。如果找不到可匹配的方法，编译器就会报告一个错误。**至此，编译器已经知道需要调用的方法的名字和参数类型**

> **注释**：方法的名字和参数列表称为方法的签名。如果在子类中定义一个与超类签名相同的方法，那么子类中的这个方法就会覆盖超类中这个相同签名的方法。
>
> 放回类型不是签名的一部分。不过在覆盖一个方法时，需要保证返回类型的兼容性。允许子类将覆盖方法的返回类型改为原返回类型的子类型。

3. 如果时`private`方法，`static`方法，`final`方法或者构造器，那么编译器将可以准确地知道应该调用哪个方法。这称为**静态绑定**。与此对应的是，如果要调用的方法依赖于隐式参数的实际类型，那么必须在运行时使用**动态绑定**。

4. 程序运行并且采用动态绑定调用方法时，虚拟机必须调用与`x`所引用对象的实际类型对应的那个方法。

#### 5.1.7 阻止继承：final类和方法

不允许拓展的类被称为`final`类。如果在定义类的时候使用了`final`修饰符就表明这个类是`final`类。声明的格式如下：

```java
public final class Executive extends Manger
{
	...
}
```

类中的某个特定方法也可以被声明为`final`，如果这样做，子类就不能覆盖这个方法。

```java
public class Employee{
	...
	public final String getName()
	{
		return name;
	}
}
```

>**注释**：对于`final`字段来说，构造对象之后就不允许改变它们的值了。如果将一个类声明为`final`，只有其中的方法自动地成为`final`，而不包括字段。

#### 5.1.8 强制类型转换

有时候需要将某个类的对象引用转换成另一个类的对象引用。要完成对象引用的强制类型转换，转换语法与数值表达式的强制类型转换类似。

```java
Manager boss = (Manager) staff[0];
```

187