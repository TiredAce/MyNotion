## 第5章 继承

>[5.1 类、超类和子类](#1.5)

<h3 id = "5.1">
5.1 类、超类和子类
</h3>

#### 5.1.1 定义子类

可以如下继承`Employee`类来定义`Manager`类，这里使用关键字`extends`表示继承。

```java
public class Manager extends Employee
{
    added methods and fields
}
```

>**C++注释**：`Java`和`C++`定义继承的方式十分相似。`Java`用关键词`extends`代替了`C++`中的`:`。在`Java`中，所有的继承都是公共继承，而没有私有继承和保护继承。

关键词`extends`表示正在构造的新类派生于一个已存在的类，这个已存在的类称为超类；新类称为子类。超类和子类是最常用的两个术语。

#### 5.1.2 覆盖方法

超类中的有些方法对子类`Manager`并不一定适用。为此，需要提供一个新的方法来覆盖超类中的这个方法。

如何实现这个方法，乍一看似乎很简单，只要放回`salary`和`bonus`字段的总和就可以了，不过，需要指出我们希望使用超类`Employee`中的`getSalary`方法，而不是当前类的这个方法。可以使用使用特殊的关键字`super`解决这个问题：

```java
super.getSalary();
```

>**注释**：有些人认为`super`与`this`引用时类似的概念，实际上，这样比较并不太恰当。这是因为`super`不是一个对象的引用，例如，不能将值`super`赋给另一个对象变量，它只是一个指示编译器调用超类方法的特殊关键词。

>**C++注释**：在`Java`中使用关键词`super`调用超类的方法，而在`C++`中则采用超类名加`::`操作符的形式。例如`Employee::getSalary`而不是`super.getSalary`。

#### 5.1.3 子类构造器

提供一个构造器

```java
public Manger(String name, double salary, int year, int month, int day)
{
	super(name, salary, year, month, day);
	bonus = 0;
}
```

这里的`super`具有不同的含义，调用超类`Employee`中带有各类参数。

子类的构造器不能访问超类的构造器，所以必须通过一个构造器来初始化这些私有字段，可以利用特殊的`super`语法调用这个构造器。使用`super`调用构造器的语句必须是子类构造器的第一条语句。

如果子类的构造器没有显示的调用超类的构造器，将自动地调用超类的无参数构造器。如果超类没有无参数构造器，并在子类中也没有显式地调用超类的其他构造器，`Java`编译器就会报告一个错误。

> **注释**：关键词`this`有两个含义:一是指示隐式参数的引用，二是调用该类的其他构造器。`super`关键字也有两个含义：一个是调用超类的方法，二是调用超类的构造器。在调用构造器的时候，`this`和`super`这两个关键字紧密相关。

一个对象变量可以指示多种实际类型的现象称为多态。在运行时能够自动地选择适当的方法，被称为动态绑定。

> **C++注释**：在`C++`中，如果希望实现动态绑定，需要成员函数声明为`virtual`。在`Java`中，动态绑定是默认的行为。如果不希望让一个方法是虚拟的，可以将它标记为`final`。

#### 5.1.5 多态

继承就是"is-a"的规则，其另一种表述是替换原则。它指出程序中出现超类对象的任何地方都可以使用子类对象替换。

```java
Employee e;
e = new Manager(...);
```

> **警告**：在`Java`中，子类引用的数组可以转换成超类引用的素组，而不需要不需要使用强制类型转换。
>
> ```java
> Manager[] managers = new Manager[10];
> ```
>
> 将它转换成`Employee[]`数组完全是合法的：
>
> ```java
> Employee[] staff = managers;
> ```
>
> 这样做肯定不会有问题，不过实际上会发生一些令人惊讶的事情。要切记`managers`和`staff`引用的是同一个数组。
>
> 这样会导致如下的语句也能实现：
>
> ```java
> staff[0] = new Employee(...);
> ```
>
> 编译器会接受这种赋值操作，这会导致会把一个普通员工混入到经理行列中，这会导致在调用经理方法时出现错误。
>
> 为了保证不发生这类破坏，所有数组都要牢记创建时的元素类型，并负责监督仅将类型兼容的引用存储到数组中。

#### 5.1.6 理解方法调用

P184