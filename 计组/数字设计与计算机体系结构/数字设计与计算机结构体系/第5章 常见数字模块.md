## 第5章 常见数字模块

>[5.2 算术电路](#5.2)

<h3 id = "5.2">
5.2 算术电路
</h3>

#### 5.2.1 加法

1. 半加器 (half adder)

**半加法器**有两个输入`A`和`B`,两个输入`S`和`Cout`。`S`表示`A`和`B`之和。但是`2`不能用二进制表示，因此用另一输入`Cout`来表示。

元器件图与增值表如下所示：

<img src="./../assets/blog_res/第5章 常见数字模块.assets/1678936110552.png" alt="1678936110552" style="zoom:50%;" />

2. 全加器 (full adder)

**全加器**在半加器的基础上接收进位`Cin`。元器件与增值表如下所示：

<img src="./../assets/blog_res/第5章 常见数字模块.assets/image-20230316110850965.png" alt="image-20230316110850965" style="zoom:50%;" />

3. 进位传播加法器 (carry propagate adder)

一个`N`位的加法器将两个`N`位输入和一位进位`Cin`相加，产生一个`N`位结果`S`和一个输出进位`Cout`。因为进位将会传播到下一位中，这种加法器通常称为进位传播加法器。三种常见的`CPA`实现分别是**行波进位加法器**，**先行进位加法器**和**前缀加法器**。

4. 行波进位加法器 (Ripple-Carry Adder)

构造`N`位进位传播加法器最简单方法就是把`N`个全加器串联起来。行波进位加法器中一级的`Cout`就是下一级的`Cin`。这是模块化和规整化的一个应用范例：全加器模块在一个更大的系统中被多次重用。行波进位加法器有以恶搞缺点，当`N`比较大时，运行速度就会减慢。加法器的延迟$t_{ripple}$直接随位数的增长而增长，如下$t_{FA}$是全加器的延迟。

$$t_{ripple} = Nt_{FA}$$ 

<img src="./../assets/blog_res/第5章 常见数字模块.assets/image-20230316110913073.png" alt="image-20230316110913073" style="zoom:67%;" />

4. 先行进位加法器（Carry-Lookahend Adder）

先行进位加法器是另一种类型的进位传播加法器，它解决进位问题的方法是：把加法器分解成若干块，同时额外增加电路在每块一得到输入进位时就快速算出此块的输出进位。因此它不需要等待进位通过一块内的所有加法器单元，而是直接先行通过每个单元。

先行进位加法器用`G`和`P`两个信号描述一列或者一块如何确定进位输入。在不考虑进位输入的情况下，如果加法器的第`i`列必然嫩产生一个输出进位，则称为产生进位`G`。一个加法器的第`i`列在$A_i$和$B_i$都为`1`是，必产生进位`Ci`。因此第`i`列的产生信号`Gi`可以这样计算:

$$G_i = A_i B_i$$

如果在有进位输入时，第`i`列产生一个进位输出，那么称为传播进位。如果`Ai`和`Bi`为`1`，第`i`列就会传播一个进位输入`Ci-1`：

$$P_i = A_i + B_i$$

利用这些定义，可以为加法器的特定列重写进位逻辑。如过加法器的第`i`列会产生一个进位$G_i$或者传播进位输入$P_iC_{i-1}$，它就会产生进位输出`Ci`,表达式如下：

$$C_i=A_iB_i+(A_i + B_i)C_{i-1} = G_i+P_iC_{i-1}$$

产生和传播的定义可以拓展到多位构成的块。如果一个块在不考虑进位输入的情况下也能产生进位输入，称其产生进位。如果一个块在有进位输入时候产生进位，称其为传播进位。定义$G_{i:j}$和$P_{i:j}$为从第`i`位到第`j`位块的产生和传播信号。

一个块产生一个进位信号的条件时：最高位列产生一个进位，或入股最高列传播进位而且之前的列产生了进位，例如，一个`3`列到第`0`列块产生的逻辑如下：

$$G_{3:0}=G_3+P_3(G_2 + P_2(G_1 + P_1G_0))$$

一个块传播进位的条件：块中所有的列都能传播进位，传播逻辑如下：

$$P_{3:0}=P_3P_2P_1P_0$$

使用块的产生和传播信号，可以根据块的进位输入$C_j$快速计算除块的进位输出$C_i$

$$C_i = G_{i:j} + P_{i:j}C_j$$

<img src="./../assets/blog_res/第5章 常见数字模块.assets/image-20230316110932273.png" alt="image-20230316110932273" style="zoom: 50%;" />

所有的`CLA`单元同时地计算一位并产生块的生成和传播信号。关键路径从首个`ClA`块中计算$G_0$和$G_{3:0}$开始。接着$C_{in}$直接通过每块中的门电路向前传输，直到最后。在大型的加法器中，这会比等待所有的进位波式通过每一个加法器快很多。最后，关键路径通过最后一个块中包含的短行波进位加法器。因此，一个分解成`k`位块的`N`位加法器延迟为：

$$t_{CLA}=t_{pg}+t_{pg\_block}+(\frac{N}{k}-1)t_{AND\_OR}+kt_{FA}$$

式中$t_{pg}$为单独一个生成产生信号`P`和传播`G`的门电路，$t_{pg \_block}$为在`k`位块中产生信号$P_{i:j}$和$G_{i:j}$的延迟，$t_{AND \_OR}$子位在`k`位`CLA`块中`Cin`到`Cout`的延迟。

#### 5.2.2 减法

减法非常简单：改变减数的符号，然后做加法。改变二进制补码的符号就是反转所有的位，然后加`1`。

为了计算$Y=A-B$，首先创建$B$的二进制补码。反转$B$的所有位得到$\bar{B}$,然后加`1`得到$-B=\bar{B}+1$。把这个值与被减数`A`相加，得到$Y=A+\bar{B}+1=A-B$。可以通过进位传播加法器得到和，其中设置$C_{in} = 1$，加数和被加数分别为$A$和$\bar{B}$。如图为减法器的符号以及实现。

<img src="./../assets/blog_res/第5章 常见数字模块.assets/image-20230316112000290.png" alt="image-20230316112000290" style="zoom:50%;" />

#### 5.2.3 比较器

比较器的作用时判断两个二进制是否相等，或者一个比另一个大还是小。比较器的输入为两个$N$为而二进制$A$和$B$。

有两种常见类型的比较器。**相等比较器**产生一个输出，说明是否相等；**量值比较器**产生一个或者多个输出，说明两者的关系值。

1. 相等比较器

相等比较器的硬件相对简单，首先通过`XNOR`门电路检查每一列的对应位是否相等。如果列的每一位都相等，则它们就相等。

<img src="./../assets/blog_res/第5章 常见数字模块.assets/image-20230316112557030.png" alt="image-20230316112557030" style="zoom:50%;" />

2. 量值比较器

量值比较器首先计算$A-B$的值，然后检查结果的符号位（最高有效位），如果结果是负的（即符号位为1），则$A$小于$B$；否则，$A$大于或等于$B$。

<img src="./../assets/blog_res/第5章 常见数字模块.assets/image-20230316113039412.png" alt="image-20230316113039412" style="zoom:50%;" />

#### 5.2.4 算术逻辑单元

算术逻辑单元(Arithmetic/Logical Unit, ALU)将多种算术和逻辑运算组合到一个单元内。典型的算术逻辑单元能执行加法、减法、量值比较、`AND`和`OR`运算。`ALU`是大多数计算机的核心。

给出一个具有`N`位输入和`N`位输出的算术逻辑单元的电路符号。算法逻辑单元接受说明执行哪个功能的控制信号`F`。如下列出了`ALU`可以执行的典型功能。

<img src="./../assets/blog_res/第5章 常见数字模块.assets/image-20230316114222956.png" alt="image-20230316114222956" style="zoom:50%;" />

该`ALU`包含一个`N`位加法器和`N`个`2`输入`AND`和`OR`门；反相器；当$F_2$控制信号有效时反转输入`B`的复用器。`4:1`复用器根据$F_{1:0}$控制信号选择所需要的功能。

<img src="./../assets/blog_res/第5章 常见数字模块.assets/image-20230316115345758.png" alt="image-20230316115345758" style="zoom:50%;" />

`ALU`中的算术和逻辑单元对`A`和`BB`进行运算。`BB`是$B$和$\bar B$，取决于$F_2$。如果$F_{1:0}=00$，则输出复用器就选择`AND`。如果$F_{1:0}=01$，则输出复用器就选择`OR`。如果$F_{1:0}=10$，则算术逻辑单元就执行加法或减法。做加法还是减法取决于$F_2$。

当$F_{2:0}=111$时，算术逻辑单元就执行小于则置位，当$A < B$时，$Y = 1$；否则，$Y = 0$。

通过计算$S=A-B$实现$SLT$。如果$S$是负数，则$A<B$。*零扩展单元*通过将它的`1`位输入与高位的`0`连接起来产生`N`位输出。`S`的符号位（第N-1位）是零扩展单元的输入。

#### 5.2.5 移位器和循环移位器

