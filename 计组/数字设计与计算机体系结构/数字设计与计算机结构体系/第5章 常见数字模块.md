## 第5章 常见数字模块

>[5.2 算术电路](#5.2)

<h3 id = "5.2">
5.2 算术电路
</h3>

#### 5.2.1 加法

1. 半加器 (half adder)

**半加法器**有两个输入`A`和`B`,两个输入`S`和`Cout`。`S`表示`A`和`B`之和。但是`2`不能用二进制表示，因此用另一输入`Cout`来表示。

元器件图与增值表如下所示：

<img src="./../assets/blog_res/第5章 常见数字模块.assets/image-20230307113840129.png" alt="image-20230307113840129" style="zoom:50%;" />

2. 全加器 (full adder)

**全加器**在半加器的基础上接收进位`Cin`。元器件与增值表如下所示：

<img src="./../assets/blog_res/第5章 常见数字模块.assets/image-20230307114512585.png" alt="image-20230307114512585" style="zoom:50%;" />

3. 进位传播加法器 (carry propagate adder)

一个`N`位的加法器将两个`N`位输入和一位进位`Cin`相加，产生一个`N`位结果`S`和一个输出进位`Cout`。因为进位将会传播到下一位中，这种加法器通常称为进位传播加法器。三种常见的`CPA`实现分别是**行波进位加法器**，**先行进位加法器**和**前缀加法器**。

4. 行波进位加法器 (Ripple-Carry Adder)

构造`N`位进位传播加法器最简单方法就是把`N`个全加器串联起来。行波进位加法器中一级的`Cout`就是下一级的`Cin`。这是模块化和规整化的一个应用范例：全加器模块在一个更大的系统中被多次重用。行波进位加法器有以恶搞缺点，当`N`比较大时，运行速度就会减慢。加法器的延迟$t_{ripple}$直接随位数的增长而增长，如下$t_{FA}$是全加器的延迟。

$$t_{ripple} = Nt_{FA}$$ 

<img src="./../assets/blog_res/第5章 常见数字模块.assets/image-20230314104045413.png" alt="image-20230314104045413" style="zoom: 50%;" />

4. 先行进位加法器（Carry-Lookahend Adder）

先行进位加法器是另一种类型的进位传播加法器，它解决进位问题的方法是：把加法器分解成若干块，同时额外增加电路在每块一得到输入进位时就快速算出此块的输出进位。因此它不需要等待进位通过一块内的所有加法器单元，而是直接先行通过每个单元。

先行进位加法器用`G`和`P`两个信号描述一列或者一块如何确定进位输入。在不考虑进位输入的情况下，如果加法器的第`i`列必然嫩产生一个输出进位，则称为产生进位`G`。一个加法器的第`i`列在$A_i$和$B_i$都为`1`是，必产生进位`Ci`。因此第`i`列的产生信号`Gi`可以这样计算:

$$G_i = A_i B_i$$

如果在有进位输入时，第`i`列产生一个进位输出，那么称为传播进位。如果`Ai`和`Bi`为`1`，第`i`列就会传播一个进位输入`Ci-1`：

$$P_i = A_i + B_i$$

利用这些定义，可以为加法器的特定列重写进位逻辑。如过加法器的第`i`列会产生一个进位$G_i$或者传播进位输入$P_iC_{i-1}$，它就会产生进位输出`Ci`,表达式如下：

$$C_i=A_iB_i+(A_i + B_i)C_{i-1} = G_i+P_iC_{i-1}$$

产生和传播的定义可以拓展到多位构成的块。如果一个块在不考虑进位输入的情况下也能产生进位输入，称其产生进位。如果一个块在有进位输入时候产生进位，称其为传播进位。定义$G_{i:j}$和$P_{i:j}$为从第`i`位到第`j`位块的产生和传播信号。

一个块产生一个进位信号的条件时：最高位列产生一个进位，或入股最高列传播进位而且之前的列产生了进位，例如，一个`3`列到第`0`列块产生的逻辑如下：

$$G_{3:0}=G_3+P_3(G_2 + P_2(G_1 + P_1G_0))$$

一个块传播进位的条件：块中所有的列都能传播进位，传播逻辑如下：

$$P_{3:0}=P_3P_2P_1P_0$$

使用块的产生和传播信号，可以根据块的进位输入$C_j$快速计算除块的进位输出$C_i$

$$C_i = G_{i:j} + P_{i:j}C_j$$

<img src="./../assets/blog_res/第5章 常见数字模块.assets/image-20230314115113973.png" alt="image-20230314115113973" style="zoom:50%;" />

所有的`CLA`单元同时地计算一位并产生块的生成和传播信号。关键路径从首个`ClA`块中计算$G_0$和$G_{3:0}$开始。接着$C_{in}$直接通过每块中的门电路向前传输，直到最后。在大型的加法器中，这会比等待所有的进位波式通过每一个加法器快很多。最后，关键路径通过最后一个块中包含的短行波进位加法器。因此，一个分解成`k`位块的`N`位加法器延迟为：

$$t_{CLA}=t_{pg}+t_{pg\_block}+(\frac{N}{k}-1)t_{AND\_OR}+kt_{FA}$$

式中$t_{pg}$为单独一个生成产生信号`P`和传播`G`的门电路，$t_{pg \_block}$为在`k`位块中产生信号$P_{i:j}$和$G_{i:j}$的延迟，$t_{AND \_OR}$子位在`k`位`CLA`块中`Cin`到`Cout`的延迟。