## Shell工具

>[1. 概论](#1)
>
>[2. 注释](#2)
>
>[3. 变量](#3)
>
>[4. 默认变量](#4)
>
>[5. 数组](#5)
>
>[6. expr命令](#6)

<h3 id = "1">
1. 概论
</h3>
`Shell`是我们通过命令与操作系统沟通的语言，`Shell`脚本可以直接在命令行中执行，也可以将一套逻辑组织成一个文件，方便服用。

`Linux`系统中一般默认使用`bash`，所以接下来讲解`bash`中的语法。脚本文件开头需要加上`#!/bin/bash`，指明`bash`为脚本解释器。

#### 1.2 脚本实例

新建一个`test.sh`文件，写入以下内容:

```shell
#! /bin/bash
echo "Hello World!"
```

#### 1.3 运行脚本

通过`chmod`命令使脚本具有可执行权限

```shell
chmod +x test.sh
```

在当面路径下执行：

```shell
./test.sh  # 当前路径下执行
Hello World!
```

用解释器执行：

```bash
bash test.sh  # 解释器执行
Hello World!
```

#### 1.4 查看命令如何使用

最常见的方法是为对应的命令添加`-h`或`--help`标记。另外一个更详细的方法是使用`man`命令，它提供了命令的用户手册。

有时候手册内容太过详细，让我们难以在其中查找哪些最常用的标记和语法。[tldr pages](https://tldr.sh/)是一个不错的替代品，可以帮助用户快速找到正确的选项。

<h3 id = "2">
2. 注释
</h3>

#### 2.1 单行注释

在行中`#`之后的内容都是注释

```shell
# 这是注释
echo "Hello"  #这也是注释
```

#### 2.2 多行注释

格式如下所示：

```shell
:<<EOF
注释1
注释2
注释3
EOF
```

其中的`EOF`可以替换成其他任意的字符串，但是必须在结尾有相匹配的标识符。

<h3 id = "3">
3. 变量
</h3>

#### 3.1 定义变量

定义变量不需要加`$`符号，如下所示：

```shell
name1='zst' # 单引号定义字符串
name2="zst" # 双引号定义字符串
name3=zst # 也可以不加引号， 同样表示字符串
```

**注意**：定义变量时要小心多余的空格。

#### 3.2 使用变量

使用变量需要加上`$`符号，或者`${}`符号，花括号是可以选择的，主要是为了帮助解释器识别变量边界。

```shell
name=zst
echo $name # 输出 zst
echo ${name} # 输出 zst
echo ${name}ac # 输出 zstacwing
```

#### 3.3 只读变量

可以使用`readonly`或者`declare -r`将变量变成只读变量。

```shell
name=zst
readonly name
declare -r name # 两种写法均可

name=abc # 会报错，因为此时name是只读变量
```

#### 3.4 删除变量

`unset`可以删除变量

```shell
name=zst
unset name
echo $name   # 输出空行
```

#### 3.5 变量类型

1. 自定义变量（局部变量）子进程不能访问的变量
2. 环境变量（全局变量）子进程可以访问的变量

自定义变量改成环境变量：

```shell
name=cbh
export name   # 第一种方式
declare -x name   # 第二种方式
```

环境变量改为自定义变量：

```shell
export name=cbh
declare +x name
```

#### 3.6 字符串

字符串可以使用双引号，单引号，也可以不用引号。

双引号和单引号的区别：

* 单引号中的内容会原样输出，不会执行，不会取变量
* 双引号中的内容可以执行，可以取变量

1. 获取字符串长度

```shell
name=cbh
echo ${#name}    # 输出3
```

2. 提取子串

```shell
name="HelloWorld"
echo ${name:0:5}   # 输出Hello
```

<h3 id = "4">
4. 默认变量
</h3>

`bash`使用了很多特殊的变量来表示参数、错误代码和相关变量。下下面是距离来其中一些变量，更完整的里列表可以参考[这里](https://tldp.org/LDP/abs/html/special-chars.html)

* `$0` 脚本名

* `$1`到`$9` 脚本的参数。`$1`是第一个参数，以此类推

* `$@` 由所有参数构成的用双引号括起来的字符串
* `#*` 由所有参数构成的用空格隔开的字符串
* `$#` 参数个数
* `$?` 前一个命令的返回值
* `$$` 当前脚本的进程识别符

<h3 id = "5">
5. 数组
</h3>

数组中可以存放多个不同类型的值，只支持一维数组，初始化时不需要指明数组大小。数组下标从`0`开始。

#### 5.1 数组的定义

数组用小括号来表示，元素之间用空格隔开。例如：

```shell
array=(1 abs "def" zst)
```

也可以直接定义数组总某个元素的值：

```shell
array[0] = 1
array[4] = zst
```

#### 5.2 读取数组中某个元素的值

读取格式为`${array[index]}`，例如：

```shell
array=(1 abc "def")
echo ${array[0]}
```

#### 5.3 读取整个数组

读取格式`${array[@]}`或者`${array[*]}`

#### 5.4 数组长度

类似于字符串，自会计算被赋值了的下标`${#array[@]} `或`${#array[*]}`。

```shell
array=()
array[0]=1
array[2]=2
echo ${#array@]}   # 输出2
```

<h3 id = "6">
6. expr命令
</h3>

`expr`命令用来求表达式的值，格式为`expr 表达式`。

#### 6.1 字符串表达式

* `length STRING` 返回`STRING`的长度
* `index STRING CHARSET` 任意单个字符在`STRING`中最前面的字符位置，下标从`1`开始。如果在`STRING`中完全不存在`CHARSET`中的字符，则会返回`0`。
* `substr STRING POSITION LENGTH`返回`STRING`字符串中从`POSITION`开始，长度最大为`LENGTH`的子串。如果`POSITION`或`LENGTH`为负值、`0`或非数值，则返回空字符串。

示例：

````shell
str="Hello World!"

echo `expr length "$str"`  # ``不是单引号，表示执行该命令，输出12
echo `expr index "$str" aWd`  # 输出7，下标从1开始
echo `expr substr "$str" 2 3`  # 输出 ell
````

#### 6.2 整数表达式

`expr`支持普通的算术操作，算术表达式优先级低于字符串表达式，高于逻辑关系表达式。

* `+ -` 加减运算，两端参数会转换为整数，如果转换失败则报错。
* `* / %` 乘除模运算，两端参数会转换为整数，如果转换失败则报错。
* `()` 可以改变优先级，但需要使用反斜杠转义。

示例：

```shell
a=3
b=4

echo `expr $a + $b`  # 输出7
echo `expr $a - $b`  # 输出-1
echo `expr $a \* $b`  # 输出12，*需要转义
echo `expr $a / $b`  # 输出0，整除
echo `expr $a % $b` # 输出3
echo `expr \( $a + 1 \) \* \( $b + 1 \)`  # 输出20，值为(a + 1) * (b + 1)
```

#### 6.3 逻辑关系表达式

* `|`如果第一个参数表非空且非`0`，则返回第一个参数的值，否则返回第二个参数的值，但要求第二个参数的值也是非空或非`0`，否则返回`0`。该运算具有短路的特性。

* `&`如果两个参数都非空且非`0`，则返回第一个参数，否则返回`0`。如果第一个参数为`0`或为空，则不会计算第二个参数。

* `< <= = == != >= >` 比较两端的参数，如果为true，则返回1，否则返回0。”==”是”=”的同义词。”expr”首先尝试将两端参数转换为整数，并做算术比较，如果转换失败，则按字符集排序规则做字符比较。
* `()` 可以改变优先级，但需要使用反斜杠转义。

示例：

```shell
a=3
b=4

echo `expr $a \> $b`  # 输出0，>需要转义
echo `expr $a '<' $b`  # 输出1，也可以将特殊字符用引号引起来
echo `expr $a '>=' $b`  # 输出0
echo `expr $a \<\= $b`  # 输出1

c=0
d=5

echo `expr $c \& $d`  # 输出0
echo `expr $a \& $b`  # 输出3
echo `expr $c \| $d`  # 输出5
echo `expr $a \| $b`  # 输出3
```

