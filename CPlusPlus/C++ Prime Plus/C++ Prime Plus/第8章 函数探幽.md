## 第8章 函数探幽

>[8.1 C++内联函数](#8.1)
>
>[8.4 函数重载](#8.4)
>
>[8.5函数模板](#8.5)

<h3 id="8.1">
    8.1 C++内联函数
</h3>

​		内联函数是`C++`为降低小程序调用开销的一种机制，函数重载是以同一个名字命名多个函数实现版本。

​		要使用这种特性，必须采取下述措施之一：

* 在函数声明前加上关键字 `inline`
* 在函数定义前加上关键字 `inline`

​		注意：不能同时在声明和定义加上`inline`关键字，这会导致重复说明。(存在编译器优化)

<h3 id="8.4">
    8.4 函数重载
</h3>


​		函数重载的关键是函数的参数列表，也成为函数特征标。如果两个函数的参数数目和类型相同，同时参数的排列顺序也相同，则它们的特征标相同。`C++`允许定义名称相同的函数，条件是它们的特征标不同。如果参数数目和参数类型不同，则特征标也不同。

<h3 id="8.5"> 
    8.5 函数模板
</h3>

​		`C++`编译器实现了一项新特性——函数模板。函数模板是通用的函数描述，它们使用泛型来定义函数，其中的反省可用具体的类型来替换。通过将类型作为参数传递给模板，可使编译器生成该类型的函数。由于模板允许以泛型方式编写程序，因此有时也可被称为通用程序。例如，如下交换函数代码：

```c++
template <typename AnyType>
void swap(AnyType &a, AnyType &b)
{
	AnyType temp;
	temp = a;
	a = b;
	b = temp;
}
```

​	第一行指出，要建立一个模板，并将类型命名为`AnyType`。关键词`template`和`typename`是必须的，除非可以使用关键字`class`代替`typename`。另外，必须使用尖括号。一般用`T`来代替使用简单的名称。余下的代码描述了如何交换两个值的算法。模板不创建任何函数，而只是告诉编译器如何定义函数。需要交换`int`的函数时。编译器将按模板模式创建这样的函数，并用`int`代替`AnyType`。

#### 8.5.1 重载的模板

​		并非所有的类型都使用相同的算法。为满足这种要求，可以像重载常规函数定义那样重载模板定义。和常规重载一样，被重载的模板的函数特征标必须不同。例如，交换数组的重载函数声明：

```c++
template <typename T>
void swap(T &a, T &b);

template <typename T>
void swap(T *a, T *b, int n);
```

#### 8.5.2 模板的局限性

​		编写的模板函数可能无法处理某些类型。另一方面，有时候通用化是有必要的，但`C++`语法不允许这样做。例如，将两个包含位置坐标的结构相加是有意义的，一种方法是重载运算符`+`，另一种解决方式是，为特定类型提供具体化的模板定义。

#### 8.5.3 显式具体化

​		待补充