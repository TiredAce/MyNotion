## 第4章 复合类型

> [4.1 数组](#4.1)
>
> [4.2 字符串](#4.2)
>
> [4.3 string类简介](#4.3)
>
> [4.4 结构简介](#4.4)
>
> [4.5 共用体](#4.5)
>
> [4.6 枚举](#4.6)
>
> [4.7 指针和自由存储空间](#4.7)
>
> [4.8 指针、数组和指针算术](#4.8)

<h3 id="4.1">4.1.数组</h3>

#### 4.1.3 C++11数组初始化方法

​		首先，初始化数组时，可以省略等号

```c++
double earings[4] {1, 2, 3, 4};
```

​		其次，可以不在大括号内包含的任何东西，表示将所有的元素都设置为零。

```c++
double earing[4] {};
```

​		最后，列表的初始化禁止缩窄转换。

```c++
long arr1[] = {25. 93. 1.0};             // no
char arr2[4] = {'h', 'i', 17772. '\0'};  // no
char arr3[4] = {'h', 'i', 17, '\0'};     // yes
```

5. 有以下说明语句，则正确的赋值语句是（    ）。
int a[5][5];  int *p, **q;
（A）p=a[0];		（B）p=&a[0];		（C）q=a[0];		（D）q=&a[0][0];


<h3 id="4.2">4.2 字符串</h3>

#### 4.2.1 拼接字符串常量
​		以下赋值语句是等效的：
```c++
char name[20] = "abc"" efg";
char name[20] = "abc efg";
```
​		第一种方式为字符串常量的拼接，第一个字符串的`/0`字符将被第二个字符串的第一个字符取代。

#### 4.2.3 字符串输入

​		`cin`使用空白来确定字符串的结束位置，这意味着`cin`在获取字符数组输入时只读取一个单词。读取该单词后，`cin`将该字符串放到数组中，并自动在结尾添加空字符。另一个问题是，输入字符串可能比目标数组长。

#### 4.2.4 每次读取一行字符串

​		要将整条短语而不是一个单词作为字符串输入，需要采用另一种字符串读取方法。在`istream`中的类提供了一些面向行的类成员函数：`getline()`和`get()`。这两个函数都读取一行输入，直到到达换行符。然而，随后`getline()`将对其换行符，而`get()`将换行符保留在输入序列中。

##### 1. 面向行的输入： getline()

​		`getline()`函数读取整行，它使用通过回车键输入的换行符来确定输入结尾。要调用这种方法，可以使用`cin.getline()`。该函数有两个 参数。第一个参数是用来存储输入行的数组的名称，第二个参数是要读取的字符数。如果这个此参数为20，则这个函数最多读取19个字符，余下的空间用于存储自动在结尾处添加的空字符。`getline()`成员函数在读取指定数目的字符或遇到换行符时停止读取。

​		例如，假设要使用`getline()`将姓名读入到一个包含20个元素的`name`数组中。可以通过：

```c++
cin.getline(name, 20);
```

​		这将把一行读入到`name`数组中——如果这行包含的字符不超过19个。

##### 2. 面向行的输入：get()

​		`istream`类有另一个名为`get()`的成员函数，该函数有几种变体。其中一种变体的工作方式与`getline()`类似，它们接受的参数相同，解释参数的方式也相同，并且都去读到行尾。但`get`并不再读取并丢弃换行符，而是将其留在输入队列中。假设连续使用两次调用`get()`:

```c++
cin.get(name, 20);
cin.get(dessert, 20);     // a problem
```

​		第一次调用时，换行符留在输入队列中，因此第二次调用时，看到的第一个字符是换行符。因此`get()`认为已到达行尾，而没有发现任何可读取的内容。如果哦不借助帮助，`get()`将不能跨过该换行符。

​		可以通过`get()`的一种变体。使用不带任何参数的`cin.get()`调用可读取下一个字符，因此此可以用它来读取换行符，为读取下一行输入做好准备。

```c++
cin.get(name, 20);
cin.get(); 				 // read newline
cin.get(dessert, 20); 
```

​		另一种使用`get()`的方式是将两个类成员函数拼接起来，如下：

```c++
cin.get(name, ArSize).get();
```

​		之所以能这样做啊，是由于` cin.get(name, ArSize)`返回一个`cin`对象，该对象随后将被用来调用`get()`函数。同样，下面的语句将把输入中连续的两行分别读入数组`name1`和`name2`中，效果调用两次`cin.getline()`相同。

```c++
cin.getline(name1, ArSize).getline(name2, ArSize);
```

##### 3. getline()和get()比较

​		为什么要使用`get()`，而不是`getline()`？首先，老式实现没有`getline()`。其次，`get()`使输入更仔细。例如，用`get()`将一行读入数组中。如何直到停止读取的原因是由于已经读取了整行，而不是由于数组已经填满？只需要查看下一个输入字符，如果是换行符，说明读取了一整行；否则，说明该行中还有其他输入。**总之，`getline()`使用起来简单一些，但`get()`使得检查错误更简单些**。可以用任意方法读取，只是应该知道，它们的行为稍微有不同。

<h3 id="4.3"> 4.3 string类简介</h3>

#### 4.3.4 string类I/O

​		使用`cin`读取`string`类对象每次读取一行而不是一个单词，使用的语法不同。将一行输入读取到数组中的代码：

```c++
cin.getline(charr, 20);
```

​		这种句点表示法表明，函数`getline()`是`istream`类的一个类方法。

​		下面将一行输入读取到`string`对象中的代码：

```c++
getline(cin, str);
```

​		这里没用使用句点表示法，这表明这个`getline()`不是类方法。它将`cin`作为参数，指出到哪里去查找输入。另外也没有指出字符串长度参数，因为`string`对象将根据字符串的长度自动调整自己的大小。

​		那么，为何一个`getline()`是`istream`的类方法，而另一个不是呢？在引入`string`类之前很久，`C++`就有`istream`类。因此`istream`的设计考虑到了基本数据类型，但没有考虑`string`类型，所以`istream`类中，有处理基本数据类型的方法，没有处理`string`类型的方法。该处理方式使用了`string`类的一个友元函数。

#### 4.3.5 其他形式的字符串字面值

​		使用前缀表示不同的字符串类型：

```c++
wchar_t title[] = L"Chief";     // w_char string
char16_t name[] = u"Ripova";    // char16_t string
char32_t car[] = U"Super";      // char32_t string
```

​		`C++11`新增的另一种类型是原始字符串。在原始字符串中，字符串就是本身，转义字符不会转义。当然，既然可以在字符串字面量包含`"`，就不能再使用它来表示字符串的开头和末尾。因此，原始字符串将`"(`和`)"`用作定界符，并使用前缀`R`来标识原始字符串：

```c++
cout << R"(Jim "King" Tutt uses "\n" instead of endl.)" << '/n';
```

<h3 id="4.4"> 4.4 结构简介</h3>

#### 4.4.2 C++11结构初始化

​		与数组一样，`C++11`也支持将列表初始化用于结构，且等号是可选的：

```c++
inflatable duck {"Daphne", 0.12, 9.98};   // can omit the = in C++11
```

​		其次，如果大括号内未包含任何东西，各个成员都将被设置为零。**最后，不允许缩窄转换。**

 #### 4.4.4 其他结构属性

​		可以使用赋值运算符`=`将结构给另一个同类型的结构，这样结构中每个成员都将被设置为另一个结构中相应成员的值，即使成员是数组。这种赋值被称为成员赋值。

<h3 id="4.5"> 4.5 共用体 </h3>

·		共用体能够存储不同的数据类型，但只能同时存储其中的一种类型。也就是说，结构可以同时能存储`int`，`long`和`double `，共用体只能存储`int`，`long`和`double `。

​		可以使用`pail`变量来存储`int`、`long`或`double`，条件是在不同的时间进行：

```c++
union st
{
    int int_val;
    double double_val;
};

st pail;
pail.int_val = 15;
cout << pail.int_val << endl;
pail.double_val = 1.38;
cout << pail.double_val << endl;
```

​		因此，`pail`有时可以是`int`，有时是`double`变量。成员名称标识了变量的容量。由于共用体每次只能存储一个值，因此它必须有足够的空间来存储最大的成员，所以，共用体的长度为其最大成员的长度。

​		共用体常用于节省内存。常用于操作系统数据结构或硬件数据结构。

<h3 id="4.6"> 4.6 枚举 </h3>

​		`enum`工具提供了另一种创建符号常量的方式，这种方式可以替代`const`。它还允许定义新类型，但必须按严格的限制进行。

```c++
enum spectrum {red, orange, yellow, green, violet};
```

* 让`spectrum`从成为新类型的名称：`spectrum`被称为枚举。
* 将`red`、`orange`、`yellow`等作为符号常量，它们对应整数值`0~4`。这些常量叫做枚举量。

​		在默认情况下，将整数值赋给枚举量，第一个枚举量的值为`0`，第二个枚举量的值为`1`。可以通过显示地指定整数值来覆盖默认值。

​		用枚举名来证明这种类型的变量：

```c++
spectrum band;
```

 		在不进行强制类型转换的情况下，只能将定义枚举时使用的枚举量赋值给这种枚举的变量。

```
band = red;    // valid, red is an enumerator
band = 3;      // not valid, 3 is not an enumerator
```

​		**枚举变量没有算术运算**：

```c++
band ++;              // not valid, 
band = orange + red   // not valid, but a little tricky   
```

​		枚举量是整型，可以被提升为`int`类型，但`int`类型不能自动转换为枚举类型：

```c++
int color = blue;     // valid, spetrum type promoted to int
band = 3;             // invalid, int not converted to spectrum
color = 3 + red;      // valid, red converted to int
```

​		如果`int`值是有效的，则可以通过强制类型转换，将它赋给枚举变量：

```c++
band = spectrum(3);  
```

​		如果试图对一个不适当的值进行强制类型转换，那么结果是不确定的，这意味着这样做不会出错，但不能依赖得到的结果：

```c++
band = spectrum(40003);   // undefine
```

​		枚举的规则相当的严格。实际上，枚举更常被用来定义相关的符号常量，而不是新类型。如果打算只使用常量，而不创建枚举类型的变量，则可以省略枚举类型的名称：

```c++
enum {red, orange, yellow, green, violet};
```

#### 4.6.1 设置枚举量的值

​		可以设置赋值运算符来显示地设置枚举量的值：

```c++
enum bits {one = 1, two = 2, four = 4};
```

​		指定的值必须是整数。也可以只显式地定义其中一些枚举量的值：

```c++
enum bits {one, two = 2, three};
```

​		这里，`one`在默认情况下为`0`，后面没有被初始化的枚举量的值将比其前面的枚举量大`1`。因此，`three`的值为`3`。

​		最后，可以创建多个值相同的枚举量：

```c++
enum {zero, null = 0, one, numero_uno = 1};
```

​		其中，`zero`和`null`都为`0`，`one`和`umero_uno`都为`1`。

#### 4.6.2 枚举的取值范围

​		假设`bits`和`myflag`的定义如下：

```c++
enum bits {one = 1, two = 2, four = 4, eight = 8};
bits myflag;
```

​		则以下的代码将是非法的：

```c++
myflag = bits(6);
```

​		其中`6`不是枚举值，但它位于枚举定义的取值范围内。

​		取值范围的定义如下，首先，找出上限，找到大于这个最大值的、最小的`2`的幂次，将它减去`1`，得到的便是取值范围的上限。如果最小的数非负，那么下限为`0`，否则计算方式与正数同理。

<h3 id="4.7"> 4.7 指针和自由存储空间 </h3>

​		使用常规变量时，值是指定的量，而地址为派生量。处理存储数据的新策略刚好相反，将地址是为指定的量，而将值视为派生量。一种特殊类型的变量——指针用于存储值的地址。`*`运算符被称为**间接值**或**解除引用**运算符，将其应用于指针，可以得到该地址处存储的值。                       

#### 4.7.2 指针的危险

​		计算机将分配用来存储地址的内存，但不会分配用来存储指针所指向的数据的内存。因此需要对指针进行初始化指向的地址。未初始化错误可能会导致一些最难以跟踪的`bug`。

#### 4.7.3 指针和数字

​		指针不是整型，虽然计算机通常把地址当作整数来处理。从概念上看，指针于整数时截然不同的类型。因此不能简单的将整数赋给指针：

```c++
int * pt;
pt = 0xB8000000;    // type mismatch
```

​		如果需要将数字值作为地址来使用，应通过强制类型转换将数字转换为适当的地址类型：

```c++
int * pt;
pt = (int *)0xB8000000;    // type now match
```

#### 4.7.4 使用new来分配内存

​		对比以下两种内存分配方式：

```c++
int * pn = new int;      // first
int higgens;             
int * pt = &higgens      // second
```

​		两种情况，都是将一个`int`变量的地址赋给了指针。第二种情况下，可以通过名称`higgens`来访问该`int`，在第一种情况下，则只能通过该指针进行访问。因此`pn`指向的内存没有名称，指的时为数据项分配的内存块。因此，变量也是数据对象，但`pn`指向的内存不是变量。处理数据对象的指针方法可能不太好用，但它使程序在管理内存方面有更大的控制权。

​		变量的值存储在被称为`栈`的内存区域中，而`new`从被称为`堆`或`自由存储区`的内存区域分配内存。

#### 4.7.5 使用delete释放内存

​		使用`delete`时，后面要加上指向内存块的指针：

```c++
int * ps = new int;
. . .
delete ps;
```

​		这将释放`ps`指向的内存，但不会删除指针`ps`本身。因此`delete`后，还能重新申请内存。

```c++
int * ps = new int;
. . .
delete ps;
ps = new int;
. . .
delete ps;
```

​		**注：只能用`delete`来释放使用`new`分配的内存。然而，对于空指针使用`delete`是安全的。**

​		使用`delete`的关键在于，它将用于`new`分配的内存，这并不意味着要使用用于`new`的指针，而是用于`new`

的地址：

```c++
int * ps = new int;
int * pt = ps;
delete pt;
```

#### 4.7.6 使用new来创建动态数组

​		如果通过声明来创建数组，则在程序被编译时将为它分配内存空间。不管程序最终是否使用数组，数组都在那里，它占用了内存。在编译时给数组分配内存被称为`静态联编`，意味着数组实在编译时加入到程序中的。但是使用`new`时，如果在运行阶段需要数组，则创建它；如果不需要，则不创建。还可以在程序运行时选择数组的长度。这被称为`动态联编`。

##### 1. 使用new创建动态数组

​		要创建一个包含`10`个`int`元素的数组，可以这样做：

```c++
int * psome = new int [10];
```

​		`new`运算符返回第一个元素的地址。在这个例子中，该地址被赋给指针`psome`。

​		当程序使用完`new`分配的内存块时，应使用`delete`释放它们。然而，对于使用`new`创建的数组，应使用另一种格式的`delete`来释放：

```c++
delete [] psome;
```

​		总之，使用`new`和`delete`时，应遵循以下规则：

* 不要使用`delete`来释放不是`new`分配的内存。
* 不要使用`delete`释放同一个内存块两次。
* 如果使用`new []` 为数组分配内存， 应使用`delete []`来释放。
* 如果使用`new []`为一个实体分配内存，则应使用`delete`来释放。
* 对空指针应用`delete`是安全的。 

​		实际上，程序跟踪了分配的内存量，以便以后使用`delete []`运算符时能够正确的释放这些内存。但这种信息时不公用的，因此，不能使用`sizeof`运算符来确定动态分配的数组包含的字节数。

<h3 id="4.8"> 4.8 指针、数组和指针算术 </h3>

#### 4.8.1 数组的地址

​		对数组取地址时，数组名也不会被解释为其地址。数组名难道不被解释为数组的地址吗？不完全如此：数组名被解释为其第一个元素的地址，而对数组名应用地址运算符时，得到的是整个数组的地址：

```c++
int tell[10];
cout << tell << endl;      // displays &tell[0]
cout << &tell << endl;     // displays address of whole array
```

​		从数字上来看，这两个地址相同；但从概念上说，前者是一个4个字节内存块的地址，而后者为40个字节的内存块地址。换句话说，`tell`是一个`int`指针（`* int`），而`&tell`是一个这样的指针，即指向包含`10`个元素的数组（`int(*)[20]`）。

​		为何`&tell`类型为这样？首先，可以这样声明和初始化这种指针：

```c++
int (*pas)[10] = &tell;
```

​		该处的`pas`的类型为`int (*)[10]`，由于`pas`被设置为`&tell`，因此`*pas`与`tell`等价，所以`(*pas)[0]`为`tell`数组的第一个元素。

#### 4.8.5 自动存储、静态存储和动态存储

##### 1. 自动存储

​		在函数内部定义的常规变量使用自动存储空间，被称为自动变量，这意味着它们在所属的函数被调用时自动产生，在该函数结束时消亡。自动变量是一个局部变量，其作用域为包含它的代码块。

​		自动变量通常存储在栈中。执行代码块时，入栈，离开代码块时，按相反顺序释放这些变量。

##### 2. 静态存储

​		静态存储是整个程序执行期间都存在的存储方式。使变量称为静态的方式有两种：一种使在函数外定义；另一种是在声明变量时使用关键字`static`。

##### 3. 动态存储

​		`new`和`delete`运算符提供了一种比自动变量和静态变量更灵活的方法。它们管理了一个内存池，即为堆。该内存池同用于静态变量和自动变量的内存是分开的。该数组的生命周期不完全受程序或函数的生存时间控制。然后，这会导致内存管理更复杂。在堆中的存储不像栈中存储总是连续的，这使得跟踪新分配内存的位置更困难。
